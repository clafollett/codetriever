//! Middleware for API request handling.
//!
//! This module provides middleware functions for common API concerns:
//! - Correlation ID generation and extraction
//! - Request/response logging
//! - Error handling middleware

use axum::{extract::Request, middleware::Next, response::Response};
use codetriever_common::CorrelationId;
use tracing::{Span, info, instrument};

/// Header name for correlation ID
pub const CORRELATION_ID_HEADER: &str = "X-Correlation-ID";

/// Request context that can be shared across middleware and handlers
#[derive(Debug, Clone)]
pub struct RequestContext {
    pub correlation_id: CorrelationId,
    pub start_time: std::time::Instant,
}

impl RequestContext {
    pub fn new() -> Self {
        Self {
            correlation_id: CorrelationId::new(),
            start_time: std::time::Instant::now(),
        }
    }

    pub fn with_correlation_id(correlation_id: CorrelationId) -> Self {
        Self {
            correlation_id,
            start_time: std::time::Instant::now(),
        }
    }
}

impl Default for RequestContext {
    fn default() -> Self {
        Self::new()
    }
}

/// Middleware to add correlation IDs to requests and responses.
///
/// This middleware:
/// 1. Extracts correlation ID from incoming request headers (if present)
/// 2. Generates a new correlation ID if none is provided
/// 3. Adds the correlation ID to the tracing span
/// 4. Includes the correlation ID in the response headers
/// 5. Logs request/response information with correlation ID
#[instrument(skip(request, next))]
pub async fn correlation_id_middleware(mut request: Request, next: Next) -> Response {
    let start_time = std::time::Instant::now();

    // Extract correlation ID from headers or generate a new one
    let correlation_id = request
        .headers()
        .get(CORRELATION_ID_HEADER)
        .and_then(|value| value.to_str().ok())
        .map_or_else(CorrelationId::new, CorrelationId::from);

    // Add correlation ID to tracing span
    Span::current().record("correlation_id", correlation_id.to_string());

    // Create request context
    let context = RequestContext::with_correlation_id(correlation_id.clone());

    // Add context to request extensions
    request.extensions_mut().insert(context.clone());

    info!(
        correlation_id = %correlation_id,
        method = %request.method(),
        uri = %request.uri(),
        "Request started"
    );

    // Process the request
    let mut response = next.run(request).await;

    // Add correlation ID to response headers
    if let Ok(header_value) = correlation_id.to_string().parse() {
        response
            .headers_mut()
            .insert("X-Correlation-ID", header_value);
    }

    let duration = start_time.elapsed();

    info!(
        correlation_id = %correlation_id,
        status = %response.status(),
        duration_ms = duration.as_millis(),
        "Request completed"
    );

    response
}

/// Axum extension to get the correlation ID from the request context.
///
/// This can be used in handlers to extract the correlation ID that was
/// generated by the `correlation_id_middleware`.
///
/// # Example
///
/// ```rust
/// use axum::extract::Extension;
/// use codetriever_api::middleware::RequestContext;
///
/// async fn my_handler(Extension(context): Extension<RequestContext>) -> String {
///     format!("Request ID: {}", context.correlation_id)
/// }
/// ```
pub fn extract_correlation_id(request: &Request) -> Option<CorrelationId> {
    request
        .extensions()
        .get::<RequestContext>()
        .map(|ctx| ctx.correlation_id.clone())
}

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used)] // OK in tests
    use super::*;
    use axum::{
        Router,
        body::Body,
        http::{Method, Request, StatusCode},
        middleware,
        response::IntoResponse,
        routing::get,
    };
    use tower::ServiceExt;

    async fn test_handler() -> impl IntoResponse {
        "Hello, World!"
    }

    #[tokio::test]
    async fn test_correlation_id_middleware_generates_id() {
        let app = Router::new()
            .route("/test", get(test_handler))
            .layer(middleware::from_fn(correlation_id_middleware));

        let response = app
            .oneshot(
                Request::builder()
                    .method(Method::GET)
                    .uri("/test")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);

        // Check that correlation ID header is present
        let correlation_id = response.headers().get("x-correlation-id");
        assert!(correlation_id.is_some());

        let correlation_id_str = correlation_id.unwrap().to_str().unwrap();
        // Verify it's a valid UUID format (new CorrelationId implementation)
        assert!(uuid::Uuid::parse_str(correlation_id_str).is_ok());
    }

    #[tokio::test]
    async fn test_correlation_id_middleware_preserves_existing_id() {
        let app = Router::new()
            .route("/test", get(test_handler))
            .layer(middleware::from_fn(correlation_id_middleware));

        // Use a valid UUID for correlation ID preservation
        let correlation_id = CorrelationId::from(uuid::Uuid::new_v4());
        let correlation_id_string = correlation_id.to_string();

        let response = app
            .oneshot(
                Request::builder()
                    .method(Method::GET)
                    .uri("/test")
                    .header(CORRELATION_ID_HEADER, &correlation_id_string)
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);

        // Check that the custom correlation ID is preserved
        let response_correlation_id = response.headers().get("x-correlation-id");
        assert!(response_correlation_id.is_some());

        let response_correlation_id_str = response_correlation_id.unwrap().to_str().unwrap();
        assert_eq!(response_correlation_id_str, &correlation_id_string);
    }

    #[test]
    fn test_request_context_creation() {
        let context = RequestContext::new();
        let uuid = context.correlation_id.to_string();
        assert!(uuid::Uuid::parse_str(&uuid).is_ok());

        let correlation_id = CorrelationId::new();
        let custom_context = RequestContext::with_correlation_id(correlation_id.clone());
        assert_eq!(custom_context.correlation_id, correlation_id);
    }
}
